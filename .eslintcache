[{"/Users/cosinew/project/archi-101/src/index.tsx":"1","/Users/cosinew/project/archi-101/src/reportWebVitals.ts":"2","/Users/cosinew/project/archi-101/src/App.tsx":"3","/Users/cosinew/project/archi-101/src/utils/map.ts":"4","/Users/cosinew/project/archi-101/src/hooks/useCanvas.ts":"5","/Users/cosinew/project/archi-101/src/hooks/useDrawing.ts":"6","/Users/cosinew/project/archi-101/src/pages/PathPage.tsx":"7","/Users/cosinew/project/archi-101/src/pages/IntroPage.tsx":"8","/Users/cosinew/project/archi-101/src/components/PathDraw.tsx":"9","/Users/cosinew/project/archi-101/src/components/Poster.tsx":"10","/Users/cosinew/project/archi-101/src/components/Video.tsx":"11","/Users/cosinew/project/archi-101/src/components/PathCanvas.tsx":"12","/Users/cosinew/project/archi-101/src/hooks/useInput.ts":"13"},{"size":500,"mtime":1609658558852,"results":"14","hashOfConfig":"15"},{"size":425,"mtime":1609658558852,"results":"16","hashOfConfig":"15"},{"size":1436,"mtime":1610874635582,"results":"17","hashOfConfig":"15"},{"size":1725,"mtime":1610980853016,"results":"18","hashOfConfig":"15"},{"size":487,"mtime":1610203610900,"results":"19","hashOfConfig":"15"},{"size":581,"mtime":1610201927809,"results":"20","hashOfConfig":"15"},{"size":5013,"mtime":1611480415174,"results":"21","hashOfConfig":"15"},{"size":399,"mtime":1610815493447,"results":"22","hashOfConfig":"15"},{"size":8008,"mtime":1611480382708,"results":"23","hashOfConfig":"15"},{"size":1047,"mtime":1610979661701,"results":"24","hashOfConfig":"15"},{"size":1853,"mtime":1611479269510,"results":"25","hashOfConfig":"15"},{"size":7030,"mtime":1611480423786,"results":"26","hashOfConfig":"15"},{"size":304,"mtime":1611474877027,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"fgrsh9",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"30"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"/Users/cosinew/project/archi-101/src/index.tsx",[],["56","57"],"/Users/cosinew/project/archi-101/src/reportWebVitals.ts",[],"/Users/cosinew/project/archi-101/src/App.tsx",[],"/Users/cosinew/project/archi-101/src/utils/map.ts",[],"/Users/cosinew/project/archi-101/src/hooks/useCanvas.ts",["58"],"/Users/cosinew/project/archi-101/src/hooks/useDrawing.ts",[],"/Users/cosinew/project/archi-101/src/pages/PathPage.tsx",[],"/Users/cosinew/project/archi-101/src/pages/IntroPage.tsx",[],"/Users/cosinew/project/archi-101/src/components/PathDraw.tsx",["59"],"/* eslint-disable react-hooks/exhaustive-deps */\nimport { useEffect, useRef, useState } from 'react';\nimport { PathPhase } from '../pages/PathPage';\nimport { LatLng } from '../utils/map';\nimport PathCanvas from './PathCanvas';\n\nimport './PathDraw.scss';\n\nconst startingImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/red_b.png',\n    new kakao.maps.Size(50, 45),\n    {\n        offset: new kakao.maps.Point(15, 43),\n    },\n);\nconst startingDragImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/red_drag.png',\n    new kakao.maps.Size(50, 64),\n    {\n        offset: new kakao.maps.Point(15, 54),\n    },\n);\n\nconst destinationImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/blue_b.png',\n    new kakao.maps.Size(50, 45),\n    {\n        offset: new kakao.maps.Point(15, 43),\n    },\n);\n\nconst destinationDragImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/blue_drag.png',\n    new kakao.maps.Size(50, 64),\n    {\n        offset: new kakao.maps.Point(15, 54),\n    },\n);\n\nexport type MapEvents = 'none' | 'dragStart' | 'dragEnd' | 'zoomStart' | 'zoomChanged';\n\ninterface PathDrawProps {\n    phase: PathPhase;\n    starting: LatLng | null;\n    destination: LatLng | null;\n    bounds: any;\n    setStarting: React.Dispatch<React.SetStateAction<LatLng | null>>;\n    setDestination: React.Dispatch<React.SetStateAction<LatLng | null>>;\n    setPhase: React.Dispatch<React.SetStateAction<PathPhase>>;\n}\n\nfunction PathDraw({ phase, starting, destination, bounds, setStarting, setDestination, setPhase }: PathDrawProps) {\n    const [map, setMap] = useState<any>(null);\n    const [mapEvent, setMapDragEvent] = useState<MapEvents>('none');\n    const [canvasCenter, setCanvasCenter] = useState<LatLng>(new kakao.maps.LatLng(37.4918782, 127.0324566));\n\n    const mapDivRef = useRef<HTMLDivElement>(null);\n    const startingMarker = useRef<any>(null);\n    const destinationMarker = useRef<any>(null);\n\n    const prevPhase = useRef<PathPhase>('searchStarting');\n\n    const overlay = useRef<any>(null);\n\n    useEffect(() => {\n        const wrap = document.getElementById('mapCanvasWrap');\n\n        wrap?.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });\n    }, []);\n\n    useEffect(() => {\n        if (mapDivRef.current) {\n            initMap();\n            setCanvasCenter(canvasCenter);\n        }\n    }, [mapDivRef]);\n\n    useEffect(() => {\n        const overlayContent = document.createElement('div');\n        overlayContent.innerHTML = `<div class=\"overlayContent\"><button id=\"confirmButton\">여기!</button></div>`;\n\n        if (starting && phase === 'confirmStarting') {\n            map.relayout();\n\n            map.setCenter(starting);\n            if (prevPhase.current !== phase) {\n                map.setLevel(4);\n                // starting\n                startingMarker.current = new kakao.maps.Marker({\n                    map: map,\n                    position: starting,\n                    draggable: true,\n                    image: startingImage,\n                });\n                kakao.maps.event.addListener(startingMarker.current, 'dragstart', function () {\n                    startingMarker.current.setImage(startingDragImage);\n\n                    if (overlay.current) {\n                        overlay.current.setMap(null);\n                    }\n                });\n                kakao.maps.event.addListener(startingMarker.current, 'dragend', function () {\n                    startingMarker.current.setImage(startingImage);\n                    setStarting(startingMarker.current.getPosition());\n                });\n\n                prevPhase.current = 'confirmStarting';\n            }\n            setCanvasCenter(starting);\n\n            startingMarker.current.setPosition(starting);\n\n            overlay.current = new kakao.maps.CustomOverlay({\n                map: map,\n                position: starting,\n                content: overlayContent,\n                yAnchor: 1,\n            });\n\n            document\n                .getElementById('confirmButton')\n                ?.addEventListener('click', () => handleConfirm('starting', overlay));\n        }\n        if (destination && phase === 'confirmDestination') {\n            map.relayout();\n\n            map.setCenter(destination);\n            if (prevPhase.current !== phase) {\n                map.setLevel(4);\n\n                // destination\n                destinationMarker.current = new kakao.maps.Marker({\n                    map: map,\n                    position: destination,\n                    draggable: true,\n                    image: destinationImage,\n                });\n                kakao.maps.event.addListener(destinationMarker.current, 'dragstart', function () {\n                    destinationMarker.current.setImage(destinationDragImage);\n\n                    if (overlay.current) {\n                        overlay.current.setMap(null);\n                    }\n                });\n                kakao.maps.event.addListener(destinationMarker.current, 'dragend', function () {\n                    destinationMarker.current.setImage(destinationImage);\n                    setDestination(destinationMarker.current.getPosition());\n                });\n\n                prevPhase.current = 'confirmDestination';\n            }\n            setCanvasCenter(destination);\n\n            destinationMarker.current.setPosition(destination);\n\n            overlay.current = new kakao.maps.CustomOverlay({\n                map: map,\n                position: destination,\n                content: overlayContent,\n                yAnchor: 1,\n            });\n\n            document\n                .getElementById('confirmButton')\n                ?.addEventListener('click', () => handleConfirm('destination', overlay));\n        }\n    }, [starting, destination, phase]);\n\n    // confirmBoth\n    useEffect(() => {\n        if (bounds) {\n            map.setBounds(bounds);\n            setCanvasCenter(map.getCenter());\n        }\n    }, [bounds]);\n\n    useEffect(() => {\n        if (map && phase === 'draw' && starting) {\n            map.setCenter(starting);\n            map.setLevel(4);\n            setCanvasCenter(starting);\n        }\n    }, [map, phase]);\n\n    const initMap = () => {\n        const kakoMap = new kakao.maps.Map(mapDivRef.current, {\n            center: canvasCenter,\n            level: 9,\n        });\n\n        // *** map events\n        kakao.maps.event.addListener(kakoMap, 'dragstart', function () {\n            console.log(kakoMap.getCenter());\n            setMapDragEvent('dragStart');\n        });\n\n        kakao.maps.event.addListener(kakoMap, 'dragend', function () {\n            setMapDragEvent('dragEnd');\n            setCanvasCenter(kakoMap.getCenter());\n        });\n\n        kakao.maps.event.addListener(kakoMap, 'zoom_start', function () {\n            setMapDragEvent('zoomStart');\n        });\n\n        kakao.maps.event.addListener(kakoMap, 'zoom_changed', function () {\n            setMapDragEvent('zoomChanged');\n            setCanvasCenter(kakoMap.getCenter());\n        });\n\n        setMap(kakoMap);\n    };\n\n    const handleConfirm = (type: 'starting' | 'destination', overlay: any) => {\n        if (overlay.current) {\n            overlay.current.setMap(null);\n        }\n\n        if (type === 'starting') {\n            setPhase('searchDestination');\n        }\n        if (type === 'destination') {\n            setPhase('confirmBoth');\n        }\n    };\n\n    const isShowing = ['confirmStarting', 'confirmDestination', 'confirmBoth', 'draw', 'viewPath'].includes(phase);\n\n    return (\n        <div className=\"PathDraw\" id=\"mapCanvasWrap\" style={{ width: true ? '97%' : 0 }}>\n            <div ref={mapDivRef} className=\"map\" id=\"map\" />\n            <PathCanvas map={map} mapElemId=\"map\" phase={phase} mapEvent={mapEvent} center={canvasCenter} />\n        </div>\n    );\n}\n\nexport default PathDraw;\n","/Users/cosinew/project/archi-101/src/components/Poster.tsx",[],"/Users/cosinew/project/archi-101/src/components/Video.tsx",[],"/Users/cosinew/project/archi-101/src/components/PathCanvas.tsx",[],"/Users/cosinew/project/archi-101/src/hooks/useInput.ts",[],{"ruleId":"60","replacedBy":"61"},{"ruleId":"62","replacedBy":"63"},{"ruleId":"64","severity":1,"message":"65","line":1,"column":29,"nodeType":"66","messageId":"67","endLine":1,"endColumn":37},{"ruleId":"64","severity":1,"message":"68","line":227,"column":11,"nodeType":"66","messageId":"67","endLine":227,"endColumn":20},"no-native-reassign",["69"],"no-negated-in-lhs",["70"],"@typescript-eslint/no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'isShowing' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]