{"version":3,"sources":["components/Poster.tsx","components/Video.tsx","pages/IntroPage.tsx","components/PathCanvas.tsx","components/PathDraw.tsx","hooks/useInput.ts","pages/PathPage.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["degrees","Poster","props","useEffect","posters","document","getElementsByClassName","i","length","poster","item","setAttribute","className","src","alt","Video","useState","videoEnded","setVideoEnded","videoRef","useRef","current","addEventListener","e","ref","controls","width","type","to","IntroPage","PathCanvas","map","mapElemId","phase","mapEvent","center","canvasRef","ctx","stageWidth","stageHeight","path","useContext","PathContext","initCavans","setTimeout","initDraw","clearRect","console","log","drawOthers","mapElem","getElementById","getContext","pixelRatio","window","devicePixelRatio","clientWidth","clientHeight","height","scale","relayout","mapProjection","getProjection","initCenter","getCenter","containterPoint","containerPointFromCoords","point","pointFromCoords","pushcounter","centerMovedX","x","centerMovedY","y","my","push","isDown","save","beginPath","lineWidth","strokeStyle","lineCap","lastCoords","lastPoint","moveTo","offsetX","offsetY","kakao","maps","Point","setCenter","coordsFromPoint","lineTo","stroke","restore","coords","_point","others","other","j","LatLng","Ma","La","style","pointerEvents","startingImage","MarkerImage","Size","offset","startingDragImage","destinationImage","destinationDragImage","PathDraw","starting","destination","bounds","setStarting","setDestination","setPhase","setMap","setMapDragEvent","canvasCenter","setCanvasCenter","mapDivRef","startingMarker","destinationMarker","prevPhase","overlay","wrap","preventDefault","passive","initMap","overlayContent","createElement","innerHTML","setLevel","Marker","position","draggable","image","event","addListener","setImage","getPosition","setPosition","CustomOverlay","content","yAnchor","handleConfirm","setBounds","kakoMap","Map","level","includes","id","useInput","initialValue","value","setValue","onChange","target","geocoder","services","Geocoder","createContext","myPath","othersPath","JSON","parse","localStorage","getItem","PathPage","startingKeyword","destinationKeyword","startingInput","destinationInput","LatLngBounds","extend","focus","Provider","onClick","addressSearch","result","status","Status","OK","latLng","pathId","uuidv4","setItem","stringify","myPathIds","App","zIndex","exact","component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.1c054105.chunk.js","sourcesContent":["import { useEffect } from 'react';\nimport './Poster.scss';\n\ninterface PosterProps {}\n\nconst degrees = [4, -4, 1, -7, 8, 3, -2];\n\nfunction Poster(props: PosterProps) {\n    useEffect(() => {\n        const posters = document.getElementsByClassName('poster');\n\n        for (let i = 0; i < posters.length; i++) {\n            const poster = posters.item(i);\n            poster?.setAttribute('style', `transform: rotate(${degrees[i]}deg)`);\n        }\n    }, []);\n\n    return (\n        <section className=\"Poster\">\n            <div className=\"poster\">\n                {/* <img src=\"/archi101-poster-0.jpg\" alt=\"poster\" /> */}\n                <img src=\"https://archi101.s3.ap-northeast-2.amazonaws.com/archi101-poster-0.jpg\" alt=\"poster\" />\n            </div>\n            <div className=\"poster\">\n                {/* <img src=\"/archi101-poster-1.jpg\" alt=\"poster\" /> */}\n                <img src=\"https://archi101.s3.ap-northeast-2.amazonaws.com/archi101-poster-1.jpg\" alt=\"poster\" />\n            </div>\n            <div className=\"poster\">\n                {/* <img src=\"/archi101-poster-2.jpg\" alt=\"poster\" /> */}\n                <img src=\"https://archi101.s3.ap-northeast-2.amazonaws.com/archi101-poster-2.jpg\" alt=\"poster\" />\n            </div>\n            <div className=\"poster\">\n                {/* <img src=\"/archi101-poster-3.jpg\" alt=\"poster\" /> */}\n                <img src=\"https://archi101.s3.ap-northeast-2.amazonaws.com/archi101-poster-3.jpg\" alt=\"poster\" />\n            </div>\n        </section>\n    );\n}\n\nexport default Poster;\n","import { useEffect, useRef, useState } from 'react';\nimport { Link } from 'react-router-dom';\n\nimport './Video.scss';\n\nfunction Video() {\n    const [videoEnded, setVideoEnded] = useState(false);\n    const videoRef = useRef<HTMLVideoElement>(null);\n\n    useEffect(() => {\n        if (videoRef) {\n            videoRef.current?.addEventListener('ended', (e) => {\n                setVideoEnded(true);\n            });\n        }\n    }, [videoRef]);\n\n    return (\n        <section className=\"Video\">\n            <p className=\"announce\">ì•„ì£¼ ì ê¹ë§Œ ë‹¤ì‹œ ë³¼ê¹Œìš”? ğŸ§</p>\n            <div className=\"video\">\n                <video ref={videoRef} controls width=\"100%\">\n                    <source\n                        src=\"https://archi101.s3.ap-northeast-2.amazonaws.com/ch1-540.mp4\"\n                        type=\"video/mp4\"\n                    ></source>\n                    {/* <source src=\"/ch1-540.mp4\" type=\"video/mp4\" /> */}\n                </video>\n                {videoEnded && (\n                    <>\n                        <div className=\"quote\">\n                            <p>\n                                ìš°ë¦¬ëŠ” ì—¬ê¸°ì„œ ë°¥ë¨¹ê³  ìˆ ë¨¹ê³  í•™êµê°€ê³  ë‹¹êµ¬ì¥ê°€ê³ , ë­ ëª¨ë“  ìƒí™œì„ ë‹¤ í•©ë‹ˆë‹¤.\n                                <br />\n                                <br />\n                                ê·¸ëŸ°ë° ê³¼ì—° ìš°ë¦¬ëŠ” ì´ ë„ì‹œì— ëŒ€í•´ì„œ ì˜ ì•Œê³ ìˆì„ê¹Œ?\n                                <br />\n                                <br />\n                                ì˜ì™¸ë¡œ ë„“ê±°ë“  ì—¬ê¸°ê°€.\n                            </p>\n                        </div>\n\n                        <Link to=\"/path\">ì í•œëª…ì”© ë‚˜ì™€ì„œ ê°ì ì˜¤ëŠ”ê¸¸ì„ í‘œì‹œí•´ë´, ì´ë ‡ê²Œ.</Link>\n                    </>\n                )}\n            </div>\n        </section>\n    );\n}\n\nexport default Video;\n","import Poster from '../components/Poster';\nimport Video from '../components/Video';\n\nfunction IntroPage() {\n    return (\n        <>\n            <section className=\"Title\">\n                <img src=\"/title-ko.png\" alt=\"title - architecture 101\" />\n                <p>ë´¤ì–´ìš”..?</p>\n            </section>\n            <Poster />\n            <Video />\n        </>\n    );\n}\n\nexport default IntroPage;\n","/* eslint-disable react-hooks/exhaustive-deps */\nimport { useContext, useEffect, useRef } from 'react';\nimport { PathPhase } from '../pages/PathPage';\nimport { LatLng, Point } from '../utils/map';\n\nimport { PathContext } from '../pages/PathPage';\nimport { MapEvents } from './PathDraw';\n\ninterface PathCanvasProps {\n    map: any;\n    mapElemId: string;\n    phase: PathPhase;\n    mapEvent: MapEvents;\n    center: LatLng;\n}\n\nfunction PathCanvas({ map, mapElemId, phase, mapEvent, center }: PathCanvasProps) {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const ctx = useRef<CanvasRenderingContext2D | null>(null);\n    const stageWidth = useRef(0);\n    const stageHeight = useRef(0);\n    const path = useContext(PathContext);\n\n    useEffect(() => {\n        if (canvasRef.current && map && !ctx.current) {\n            initCavans();\n        }\n\n        if (map && phase === 'draw') {\n            setTimeout(() => initDraw(), 1000);\n        }\n    }, [phase, map]);\n\n    useEffect(() => {\n        if (map) {\n            ctx.current?.clearRect(0, 0, stageWidth.current, stageHeight.current);\n            console.log('ue1');\n            drawOthers();\n        }\n    }, [map, center]);\n\n    useEffect(() => {\n        if (mapEvent === 'dragStart' || mapEvent === 'zoomStart') {\n            console.log('clear');\n            ctx.current?.clearRect(0, 0, stageWidth.current, stageHeight.current);\n        }\n    }, [mapEvent]);\n\n    // useEffect(() => {\n    //     if (canvasRef.current && map) {\n    //         map.setCenter(center);\n    //         map.setLevel(4);\n    //         drawPath();\n    //     }\n    // }, [center]);\n\n    const initCavans = () => {\n        if (!canvasRef.current) {\n            return null;\n        }\n\n        canvasRef.current.className = 'canvas';\n        const mapElem = document.getElementById(mapElemId);\n        ctx.current = canvasRef.current.getContext('2d');\n\n        if (!ctx.current || !mapElem) {\n            return null;\n        }\n\n        const pixelRatio = window.devicePixelRatio > 1 ? 2 : 1;\n\n        stageWidth.current = mapElem.clientWidth;\n        stageHeight.current = mapElem.clientHeight;\n\n        canvasRef.current.width = stageWidth.current * pixelRatio;\n        canvasRef.current.height = stageHeight.current * pixelRatio;\n        ctx.current.scale(pixelRatio, pixelRatio);\n\n        // let levelChanging = false;\n        // canvasRef.current.addEventListener('wheel', (e) => {\n        //     e.preventDefault();\n        //     if (Math.abs(e.deltaY) > 5 && !levelChanging) {\n        //         levelChanging = true;\n        //         map.setLevel(map.getLevel() + Math.sign(e.deltaY), { animate: true });\n        //         setTimeout(() => {\n        //             levelChanging = false;\n        //         }, 50);\n        //     }\n        // });\n\n        map.relayout();\n    };\n\n    const initDraw = () => {\n        const mapElem = document.getElementById(mapElemId);\n\n        if (!canvasRef.current || !mapElem) {\n            return;\n        }\n        const mapProjection = map.getProjection();\n\n        const initCenter = map.getCenter();\n        const containterPoint = mapProjection.containerPointFromCoords(initCenter);\n        const point = mapProjection.pointFromCoords(initCenter);\n\n        let pushcounter = 0;\n        let centerMovedX = point.x - containterPoint.x;\n        let centerMovedY = point.y - containterPoint.y;\n\n        path.my.push(map.getCenter());\n\n        let isDown = false;\n\n        canvasRef.current.addEventListener('pointerdown', (e) => {\n            isDown = true;\n\n            if (!ctx.current) {\n                isDown = false;\n                return;\n            }\n\n            ctx.current.save();\n            ctx.current.beginPath();\n\n            ctx.current.lineWidth = 5;\n            ctx.current.strokeStyle = 'rgba(255,1,2,1)';\n            ctx.current.lineCap = 'round';\n\n            const lastCoords = path.my[path.my.length - 1];\n            const lastPoint: Point = mapProjection.containerPointFromCoords(lastCoords);\n            ctx.current.moveTo(lastPoint.x, lastPoint.y);\n        });\n\n        canvasRef.current.addEventListener('pointermove', (e) => {\n            if (!isDown || !ctx.current) {\n                return;\n            }\n\n            pushcounter += 1;\n\n            if (\n                e.offsetX < 40 ||\n                e.offsetY < 40 ||\n                e.offsetX > stageWidth.current - 40 ||\n                e.offsetY > stageHeight.current - 40\n            ) {\n                isDown = false;\n                const point: Point = new kakao.maps.Point(e.offsetX + centerMovedX, e.offsetY + centerMovedY);\n                map.setCenter(mapProjection.coordsFromPoint(point));\n                centerMovedX += e.offsetX - stageWidth.current / 2;\n                centerMovedY += e.offsetY - stageHeight.current / 2;\n\n                ctx.current.clearRect(0, 0, stageWidth.current, stageHeight.current);\n                ctx.current.save();\n                ctx.current.beginPath();\n                for (let i = 0; i < path.my.length; i++) {\n                    const point: Point = mapProjection.pointFromCoords(path.my[i]);\n                    ctx.current.lineTo(point.x - centerMovedX, point.y - centerMovedY);\n                }\n                ctx.current.stroke();\n                ctx.current.restore();\n\n                drawOthers();\n            } else if (pushcounter >= 5) {\n                pushcounter = 0;\n                const point: Point = new kakao.maps.Point(e.offsetX + centerMovedX, e.offsetY + centerMovedY);\n                const coords: LatLng = mapProjection.coordsFromPoint(point);\n\n                const _point: Point = mapProjection.containerPointFromCoords(coords);\n                ctx.current.lineTo(_point.x, _point.y);\n\n                ctx.current.stroke();\n\n                path.my.push(coords);\n            }\n        });\n\n        canvasRef.current.addEventListener('pointerup', (e) => {\n            isDown = false;\n\n            ctx.current?.restore();\n        });\n    };\n\n    const drawOthers = () => {\n        if (!ctx.current) {\n            return;\n        }\n\n        console.log('draw others!');\n\n        const mapProjection = map.getProjection();\n\n        ctx.current.save();\n\n        ctx.current.lineWidth = 4;\n        ctx.current.strokeStyle = 'rgba(255,1,2,0.6)';\n        ctx.current.lineCap = 'round';\n\n        ctx.current.beginPath();\n        for (let i = 0; i < path.others.length; i++) {\n            const other = path.others[i];\n            for (let j = 0; j < other.coords?.length; j++) {\n                const point: Point = mapProjection.containerPointFromCoords(\n                    new kakao.maps.LatLng(other.coords[j].Ma, other.coords[j].La),\n                );\n                ctx.current.lineTo(point.x, point.y);\n            }\n        }\n        ctx.current.stroke();\n        ctx.current.restore();\n    };\n\n    return (\n        <canvas ref={canvasRef} className=\"canvas\" style={{ pointerEvents: phase === 'draw' ? 'inherit' : 'none' }} />\n    );\n}\n\nexport default PathCanvas;\n","/* eslint-disable react-hooks/exhaustive-deps */\nimport { useEffect, useRef, useState } from 'react';\nimport { PathPhase } from '../pages/PathPage';\nimport { LatLng } from '../utils/map';\nimport PathCanvas from './PathCanvas';\n\nimport './PathDraw.scss';\n\nconst startingImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/red_b.png',\n    new kakao.maps.Size(50, 45),\n    {\n        offset: new kakao.maps.Point(15, 43),\n    },\n);\nconst startingDragImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/red_drag.png',\n    new kakao.maps.Size(50, 64),\n    {\n        offset: new kakao.maps.Point(15, 54),\n    },\n);\n\nconst destinationImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/blue_b.png',\n    new kakao.maps.Size(50, 45),\n    {\n        offset: new kakao.maps.Point(15, 43),\n    },\n);\n\nconst destinationDragImage = new kakao.maps.MarkerImage(\n    'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/blue_drag.png',\n    new kakao.maps.Size(50, 64),\n    {\n        offset: new kakao.maps.Point(15, 54),\n    },\n);\n\nexport type MapEvents = 'none' | 'dragStart' | 'dragEnd' | 'zoomStart' | 'zoomChanged';\n\ninterface PathDrawProps {\n    phase: PathPhase;\n    starting: LatLng | null;\n    destination: LatLng | null;\n    bounds: any;\n    setStarting: React.Dispatch<React.SetStateAction<LatLng | null>>;\n    setDestination: React.Dispatch<React.SetStateAction<LatLng | null>>;\n    setPhase: React.Dispatch<React.SetStateAction<PathPhase>>;\n}\n\nfunction PathDraw({ phase, starting, destination, bounds, setStarting, setDestination, setPhase }: PathDrawProps) {\n    const [map, setMap] = useState<any>(null);\n    const [mapEvent, setMapDragEvent] = useState<MapEvents>('none');\n    const [canvasCenter, setCanvasCenter] = useState<LatLng>(new kakao.maps.LatLng(37.4918782, 127.0324566));\n\n    const mapDivRef = useRef<HTMLDivElement>(null);\n    const startingMarker = useRef<any>(null);\n    const destinationMarker = useRef<any>(null);\n\n    const prevPhase = useRef<PathPhase>('searchStarting');\n\n    const overlay = useRef<any>(null);\n\n    useEffect(() => {\n        const wrap = document.getElementById('mapCanvasWrap');\n\n        wrap?.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });\n    }, []);\n\n    useEffect(() => {\n        if (mapDivRef.current) {\n            initMap();\n            setCanvasCenter(canvasCenter);\n        }\n    }, [mapDivRef]);\n\n    useEffect(() => {\n        const overlayContent = document.createElement('div');\n        overlayContent.innerHTML = `<div class=\"overlayContent\"><button id=\"confirmButton\">ì—¬ê¸°!</button></div>`;\n\n        if (starting && phase === 'confirmStarting') {\n            map.relayout();\n\n            map.setCenter(starting);\n            if (prevPhase.current !== phase) {\n                map.setLevel(4);\n                // starting\n                startingMarker.current = new kakao.maps.Marker({\n                    map: map,\n                    position: starting,\n                    draggable: true,\n                    image: startingImage,\n                });\n                kakao.maps.event.addListener(startingMarker.current, 'dragstart', function () {\n                    startingMarker.current.setImage(startingDragImage);\n\n                    if (overlay.current) {\n                        overlay.current.setMap(null);\n                    }\n                });\n                kakao.maps.event.addListener(startingMarker.current, 'dragend', function () {\n                    startingMarker.current.setImage(startingImage);\n                    setStarting(startingMarker.current.getPosition());\n                });\n\n                prevPhase.current = 'confirmStarting';\n            }\n            setCanvasCenter(starting);\n\n            startingMarker.current.setPosition(starting);\n\n            overlay.current = new kakao.maps.CustomOverlay({\n                map: map,\n                position: starting,\n                content: overlayContent,\n                yAnchor: 1,\n            });\n\n            document\n                .getElementById('confirmButton')\n                ?.addEventListener('click', () => handleConfirm('starting', overlay));\n        }\n        if (destination && phase === 'confirmDestination') {\n            map.relayout();\n\n            map.setCenter(destination);\n            if (prevPhase.current !== phase) {\n                map.setLevel(4);\n\n                // destination\n                destinationMarker.current = new kakao.maps.Marker({\n                    map: map,\n                    position: destination,\n                    draggable: true,\n                    image: destinationImage,\n                });\n                kakao.maps.event.addListener(destinationMarker.current, 'dragstart', function () {\n                    destinationMarker.current.setImage(destinationDragImage);\n\n                    if (overlay.current) {\n                        overlay.current.setMap(null);\n                    }\n                });\n                kakao.maps.event.addListener(destinationMarker.current, 'dragend', function () {\n                    destinationMarker.current.setImage(destinationImage);\n                    setDestination(destinationMarker.current.getPosition());\n                });\n\n                prevPhase.current = 'confirmDestination';\n            }\n            setCanvasCenter(destination);\n\n            destinationMarker.current.setPosition(destination);\n\n            overlay.current = new kakao.maps.CustomOverlay({\n                map: map,\n                position: destination,\n                content: overlayContent,\n                yAnchor: 1,\n            });\n\n            document\n                .getElementById('confirmButton')\n                ?.addEventListener('click', () => handleConfirm('destination', overlay));\n        }\n    }, [starting, destination, phase]);\n\n    // confirmBoth\n    useEffect(() => {\n        if (bounds) {\n            map.setBounds(bounds);\n            setCanvasCenter(map.getCenter());\n        }\n    }, [bounds]);\n\n    useEffect(() => {\n        if (map && phase === 'draw' && starting) {\n            map.setCenter(starting);\n            map.setLevel(4);\n            setCanvasCenter(starting);\n        }\n    }, [map, phase]);\n\n    const initMap = () => {\n        const kakoMap = new kakao.maps.Map(mapDivRef.current, {\n            center: canvasCenter,\n            level: 9,\n        });\n\n        // *** map events\n        kakao.maps.event.addListener(kakoMap, 'dragstart', function () {\n            console.log(kakoMap.getCenter());\n            setMapDragEvent('dragStart');\n        });\n\n        kakao.maps.event.addListener(kakoMap, 'dragend', function () {\n            setMapDragEvent('dragEnd');\n            setCanvasCenter(kakoMap.getCenter());\n        });\n\n        kakao.maps.event.addListener(kakoMap, 'zoom_start', function () {\n            setMapDragEvent('zoomStart');\n        });\n\n        kakao.maps.event.addListener(kakoMap, 'zoom_changed', function () {\n            setMapDragEvent('zoomChanged');\n            setCanvasCenter(kakoMap.getCenter());\n        });\n\n        setMap(kakoMap);\n    };\n\n    const handleConfirm = (type: 'starting' | 'destination', overlay: any) => {\n        if (overlay.current) {\n            overlay.current.setMap(null);\n        }\n\n        if (type === 'starting') {\n            setPhase('searchDestination');\n        }\n        if (type === 'destination') {\n            setPhase('confirmBoth');\n        }\n    };\n\n    const isShowing = ['confirmStarting', 'confirmDestination', 'confirmBoth', 'draw', 'viewPath'].includes(phase);\n\n    return (\n        <div className=\"PathDraw\" id=\"mapCanvasWrap\" style={{ width: true ? '97%' : 0 }}>\n            <div ref={mapDivRef} className=\"map\" id=\"map\" />\n            <PathCanvas map={map} mapElemId=\"map\" phase={phase} mapEvent={mapEvent} center={canvasCenter} />\n        </div>\n    );\n}\n\nexport default PathDraw;\n","import { useState } from 'react';\n\nconst useInput = (initialValue: string) => {\n    const [value, setValue] = useState(initialValue);\n    const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setValue(e.target.value);\n    };\n\n    return { value, onChange };\n};\n\nexport default useInput;\n","import { createContext, useEffect, useRef, useState } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport PathDraw from '../components/PathDraw';\nimport useInput from '../hooks/useInput';\nimport { LatLng } from '../utils/map';\n\nconst geocoder = new kakao.maps.services.Geocoder();\n\nexport type PathPhase =\n    | 'searchStarting'\n    | 'confirmStarting'\n    | 'searchDestination'\n    | 'confirmDestination'\n    | 'confirmBoth'\n    | 'draw'\n    | 'viewPath';\n\ntype Path = {\n    id: string; // uuid\n    user?: string; // email\n    coords: LatLng[]; // ê²½ë¡œ ì¢Œí‘œë“¤\n    starting: LatLng;\n    destination: LatLng;\n};\n\nexport type PathContextType = {\n    others: Path[];\n    my: LatLng[];\n};\n\nexport const PathContext = createContext<PathContextType>({\n    others: [],\n    my: [],\n});\n\nconst myPath: LatLng[] = [];\nconst othersPath: Path[] = JSON.parse(window.localStorage.getItem('paths') || '[]');\n\nfunction PathPage() {\n    const [phase, setPhase] = useState<PathPhase>('searchStarting');\n    // const [phase, setPhase] = useState<PathPhase>('draw');\n\n    const startingKeyword = useInput('');\n    const destinationKeyword = useInput('');\n\n    const [starting, setStarting] = useState<LatLng | null>(null);\n    // const [starting, setStarting] = useState<LatLng | null>(new kakao.maps.LatLng(37.4918782, 127.0324566));\n    const [destination, setDestination] = useState<LatLng | null>(null);\n    const [bounds, setBounds] = useState<any>(null);\n\n    const startingInput = useRef<HTMLInputElement>(null);\n    const destinationInput = useRef<HTMLInputElement>(null);\n\n    useEffect(() => {\n        if (starting && destination && phase === 'confirmBoth') {\n            // console.log(measure(starting, destination));\n\n            const bounds = new kakao.maps.LatLngBounds();\n            bounds.extend(starting);\n            bounds.extend(destination);\n\n            setBounds(bounds);\n        }\n    }, [starting, destination, phase]);\n\n    useEffect(() => {\n        if (phase === 'searchStarting') {\n            startingInput.current?.focus();\n        }\n        if (phase === 'searchDestination') {\n            destinationInput.current?.focus();\n        }\n    }, [phase]);\n\n    const searchStarting = () => {\n        geocoder.addressSearch(startingKeyword.value, function (result: any, status: string) {\n            if (status === kakao.maps.services.Status.OK) {\n                const latLng: LatLng = new kakao.maps.LatLng(result[0].y, result[0].x);\n                console.log(latLng);\n                setStarting(latLng);\n                setPhase('confirmStarting');\n            }\n        });\n    };\n\n    const searchDestination = () => {\n        geocoder.addressSearch(destinationKeyword.value, function (result: any, status: string) {\n            if (status === kakao.maps.services.Status.OK) {\n                const latLng: LatLng = new kakao.maps.LatLng(result[0].y, result[0].x);\n                console.log(latLng);\n                setDestination(latLng);\n                setPhase('confirmDestination');\n            }\n        });\n    };\n\n    const confirmBoth = () => {\n        setPhase('draw');\n    };\n\n    const uploadPath = () => {\n        const pathId = uuidv4();\n        const path: Path = {\n            id: pathId,\n            coords: myPath,\n            starting: starting!,\n            destination: destination!,\n        };\n        window.localStorage.setItem('paths', JSON.stringify([...othersPath, path]));\n\n        const myPathIds = JSON.parse(window.localStorage.getItem('myPathIds') || '[]');\n        window.localStorage.setItem('myPathIds', JSON.stringify([...myPathIds, pathId]));\n    };\n\n    return (\n        <div className=\"PathPage\">\n            <PathContext.Provider value={{ others: othersPath, my: myPath }}>\n                <PathDraw\n                    phase={phase}\n                    starting={starting}\n                    destination={destination}\n                    bounds={bounds}\n                    setStarting={setStarting}\n                    setDestination={setDestination}\n                    setPhase={setPhase}\n                />\n            </PathContext.Provider>\n\n            {phase === 'searchStarting' && (\n                <div className=\"searchWrap\">\n                    <p>ì–´ë””ì„œ ì¶œë°œí•´ìš”?</p>\n                    <input type=\"text\" ref={startingInput} {...startingKeyword} />\n                    <button onClick={searchStarting}>ê²€ìƒ‰</button>\n                </div>\n            )}\n            {phase === 'searchDestination' && (\n                <div className=\"searchWrap\">\n                    <p>ì–´ë””ê¹Œì§€ ê°€ìš”?</p>\n                    <input type=\"text\" ref={destinationInput} {...destinationKeyword} />\n                    <button onClick={searchDestination}>ê²€ìƒ‰</button>\n                </div>\n            )}\n\n            {phase === 'confirmBoth' && <button onClick={confirmBoth}>í™•ì¸</button>}\n\n            {phase === 'draw' && <button onClick={uploadPath}>ì—…ë¡œë“œ</button>}\n        </div>\n    );\n}\n\nexport default PathPage;\n","import { Switch, Redirect, Route, BrowserRouter, Link } from 'react-router-dom';\n\nimport './App.scss';\nimport IntroPage from './pages/IntroPage';\nimport PathPage from './pages/PathPage';\n\nexport type Section = 'poster' | 'video' | 'path';\n\n// window.addEventListener(\n//     'scroll',\n//     (e) => {\n//         e.preventDefault();\n//         console.log(window.pageYOffset);\n//         const scrollValue = window.pageYOffset / (document.body.offsetHeight - window.innerHeight);\n//         if (window.pageYOffset >= 500) {\n//             window.scrollTo(0, 500);\n//         }\n//         // console.log(scrollValue);\n//         // document.body.style.setProperty('--scroll', scrollValue.toString());\n//     },\n//     false,\n// );\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <div className=\"wrap\">\n                <BrowserRouter>\n                    <header style={{ zIndex: 9999 }}>\n                        <Link to=\"/\">\n                            <img src=\"/logo.png\" height=\"40px\" alt=\"logo\" />\n                        </Link>\n                    </header>\n                    <Switch>\n                        <Route exact path=\"/\" component={IntroPage} />\n                        <Route path=\"/path\" component={PathPage} />\n                        <Redirect path=\"*\" to=\"/\" />\n                    </Switch>\n                </BrowserRouter>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}